# License: GNU AGPLv3
from itertools import chain
from functools import partial
import re

import pytest
import sklearn
from sklearn.utils.estimator_checks import check_estimator

from gtda.images.preprocessing import Binarizer, Inverter


# mark checks to skip
SKIP_TESTS = {
  'Binarizer':  [],
  'Inverter':  [],
}

# mark tests as a known failure
# TODO: these should be addressed later.
XFAIL_TESTS = {
  'Binarizer':  ["check_transformer_data_not_an_array",
                 "check_transformer_general",
                 "check_transformer_general(readonly_memmap=True)",
                 "check_fit2d_predict1d",
                 "check_fit1d"],
  'Inverter':  ["check_transformer_data_not_an_array",
                "check_transformer_general",
                "check_transformer_general(readonly_memmap=True)",
                "check_fit2d_predict1d",
                "check_fit1d"],
}

# adapted from sklearn.utils.estimator_check v0.22
def _get_callable_name(obj):
    """Get string representation of a function or a partial function name

    Examples
    --------
    >>> def f(x=2): pass
    >>> _get_callable_name(f)
    'f'
    >>> _get_callable_name(partial(f, x=1))
    'f(x=1)'
    """
    if not isinstance(obj, partial):
        return obj.__name__

    if not obj.keywords:
        return obj.func.__name__

    kwstring = ",".join(["{}={}".format(k, v)
                         for k, v in obj.keywords.items()])
    return "{}({})".format(obj.func.__name__, kwstring)


def _get_estimator_name(estimator):
    """Get string representation for classes and class instances
    
    Examples
    --------
    >>> from sklearn.preprocessing import StandardScaler
    >>> _get_estimator_name(StandardScaler)
    'StandardScaler'
    >>> _get_estimator_name(StandardScaler())
    'StandardScaler'
    """
    if isinstance(estimator, type):
       # this is class
       return estimator.__name__
    else:
       # this an instance
       return estimator.__class__.__name__


# adapted from sklearn.utils.estimator_check v0.22
def _set_check_estimator_ids(obj):
    """Create pytest ids for checks.
    When `obj` is an estimator, this returns the pprint version of the
    estimator (with `print_changed_only=True`). When `obj` is a function, the
    name of the function is returned with its keyworld arguments.
    `_set_check_estimator_ids` is designed to be used as the `id` in
    `pytest.mark.parametrize` where `check_estimator(..., generate_only=True)`
    is yielding estimators and checks.
    Parameters
    ----------
    obj : estimator or function
        Items generated by `check_estimator`
    Returns
    -------
    id : string or None
    See also
    --------
    check_estimator
    """
    if callable(obj):
       return _get_callable_name(obj)

    if hasattr(obj, "get_params"):
        with sklearn.config_context(print_changed_only=True):
            return re.sub(r"\s", "", str(obj))



def yield_common_checks(estimators):
    """Yield checks for a list of estimators

    Parameters
    ----------
    estimators : list of estimators objects or classes
        Estimators to generated checks for.
    Yields
    ------
    estimator
        the estimator to check
    check : callable
         
    """
    for estimator, check in chain.from_iterable(
        check_estimator(estimator, generate_only=True)
        for estimator in estimators
    ):
        estimator_name = _get_estimator_name(estimator)
        if _get_callable_name(check) in SKIP_TESTS[estimator_name]:
            # skip this test
            continue
        yield estimator, check


@pytest.mark.parametrize(
    "estimator, check",
    yield_common_checks([Binarizer, Inverter]),
    ids=_set_check_estimator_ids
)
def test_sklearn_api(check, estimator, request):
    estimator_name = _get_estimator_name(estimator)
    if _get_callable_name(check) in XFAIL_TESTS[estimator_name]:
        # mark tests as a known failure
        request.applymarker(pytest.mark.xfail(run=True, reason='known failure'))
    
    check(estimator)
